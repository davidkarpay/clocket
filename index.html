<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Court Hearing Recorder</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #2c3e50;
        }
        
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }
        
        .file-upload {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            text-align: center;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .file-input {
            display: none;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: #3498db;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s;
        }
        
        .file-input-label:hover {
            background: #2980b9;
        }
        
        .hearings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .hearing-tile {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .hearing-tile:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .hearing-tile.recording {
            border: 2px solid #e74c3c;
            background: #fff5f5;
        }
        
        .case-header {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .case-number {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .client-name {
            font-size: 16px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        
        .case-info {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #95a5a6;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-start {
            background: #27ae60;
            color: white;
        }
        
        .btn-start:hover:not(:disabled) {
            background: #229954;
        }
        
        .btn-stop {
            background: #e74c3c;
            color: white;
        }
        
        .btn-stop:hover:not(:disabled) {
            background: #c0392b;
        }
        
        .btn-transcript {
            background: #9b59b6;
            color: white;
        }
        
        .btn-transcript:hover:not(:disabled) {
            background: #8e44ad;
        }
        
        .btn-download {
            background: #34495e;
            color: white;
        }
        
        .btn-download:hover:not(:disabled) {
            background: #2c3e50;
        }
        
        .notes-section {
            margin-top: 15px;
        }
        
        .notes-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #2c3e50;
        }
        
        .notes-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
        }
        
        .notes-textarea:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .status {
            margin-top: 10px;
            padding: 8px 12px;
            background: #ecf0f1;
            border-radius: 4px;
            font-size: 13px;
            color: #7f8c8d;
        }
        
        .status.recording {
            background: #e74c3c;
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .status.processing {
            background: #f39c12;
            color: white;
        }
        
        .status.complete {
            background: #27ae60;
            color: white;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .recording-time {
            font-weight: 600;
            margin-left: 8px;
        }
        
        .transcript-preview {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            max-height: 200px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #95a5a6;
        }
        
        .empty-state h3 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #7f8c8d;
        }
        
        @media (max-width: 768px) {
            .hearings-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }

        /* Speaking Time Tracker Styles */
        .speaking-time-tracker {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .tracker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .tracker-header h3 {
            margin: 0;
            font-size: 18px;
            color: #2c3e50;
        }

        .hearing-timer {
            font-size: 16px;
            color: #7f8c8d;
        }

        .timer-display {
            font-weight: 600;
            color: #2c3e50;
            font-family: monospace;
            font-size: 18px;
        }

        .party-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .party-button {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .party-button:hover {
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .party-button.active {
            border-color: #e74c3c;
            background: #fff5f5;
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.2);
            animation: pulse 1.5s infinite;
        }

        .party-name {
            font-weight: 600;
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .party-time {
            font-size: 20px;
            font-weight: 700;
            color: #3498db;
            font-family: monospace;
        }

        .party-button.active .party-time {
            color: #e74c3c;
        }

        .tracker-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn-recess {
            background: #e74c3c;
            color: white;
            flex: 1;
        }

        .btn-recess:hover:not(:disabled) {
            background: #c0392b;
        }

        .btn-reset {
            background: #95a5a6;
            color: white;
        }

        .btn-reset:hover {
            background: #7f8c8d;
        }

        .add-party-section {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .add-party-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .btn-add {
            background: #27ae60;
            color: white;
            padding: 10px 20px;
        }

        .btn-add:hover {
            background: #229954;
        }

        .current-speaker-indicator {
            text-align: center;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 8px;
            border: 2px solid #4caf50;
        }

        .speaker-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .speaker-name {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .speaker-time {
            font-size: 32px;
            font-weight: 700;
            color: #4caf50;
            font-family: monospace;
        }

        /* Report Styles */
        .speaking-report {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .speaking-report h4 {
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 20px;
        }

        .report-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .summary-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .summary-item .label {
            display: block;
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .summary-item .value {
            display: block;
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            font-family: monospace;
        }

        .party-stats {
            margin-bottom: 30px;
        }

        .party-stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            margin-bottom: 10px;
        }

        .party-stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .party-stat-header .party-name {
            font-weight: 600;
            font-size: 16px;
            color: #2c3e50;
        }

        .party-stat-header .party-percentage {
            font-size: 20px;
            font-weight: 700;
            color: #3498db;
        }

        .party-stat-details {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 10px;
        }

        .party-stat-bar {
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
        }

        .party-stat-fill {
            height: 100%;
            background: #3498db;
            transition: width 0.5s ease-out;
        }

        .chart-container {
            text-align: center;
            margin: 30px 0;
        }

        .chart-container canvas {
            max-width: 100%;
            height: auto;
        }

        .report-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-save {
            background: #27ae60;
            color: white;
        }

        .btn-save:hover {
            background: #229954;
        }

        .btn-close {
            background: #95a5a6;
            color: white;
        }

        .btn-close:hover {
            background: #7f8c8d;
        }

        /* Deposition Mode Styles */
        .deposition-mode {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            text-align: center;
        }

        .deposition-mode h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .deposition-mode p {
            opacity: 0.9;
            margin-bottom: 25px;
        }

        .deposition-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .btn-deposition {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-deposition-start {
            background: #27ae60;
            color: white;
        }

        .btn-deposition-start:hover {
            background: #219a52;
            transform: translateY(-2px);
        }

        .btn-deposition-pause {
            background: #f39c12;
            color: white;
        }

        .btn-deposition-pause:hover {
            background: #d68910;
        }

        .btn-deposition-resume {
            background: #3498db;
            color: white;
        }

        .btn-deposition-resume:hover {
            background: #2980b9;
        }

        .btn-deposition-stop {
            background: #e74c3c;
            color: white;
        }

        .btn-deposition-stop:hover {
            background: #c0392b;
        }

        .btn-deposition:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .deposition-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            font-size: 18px;
            font-weight: 500;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-recording {
            background: #e74c3c;
        }

        .status-paused {
            background: #f39c12;
        }

        .status-stopped {
            background: #95a5a6;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .deposition-info {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .info-item {
            text-align: center;
        }

        .info-value {
            font-size: 24px;
            font-weight: bold;
            display: block;
        }

        .info-label {
            font-size: 12px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mode-toggle {
            margin-bottom: 20px;
            text-align: center;
        }

        .btn-mode-toggle {
            background: #8e44ad;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn-mode-toggle:hover {
            background: #7d3c98;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // Deposition Mode Component
        function DepositionMode() {
            const [isRecording, setIsRecording] = useState(false);
            const [isPaused, setIsPaused] = useState(false);
            const [duration, setDuration] = useState(0);
            const [audioBlob, setAudioBlob] = useState(null);
            const [recorder, setRecorder] = useState(null);
            const intervalRef = useRef(null);
            const startTimeRef = useRef(null);
            const pausedTimeRef = useRef(0);

            // Format duration for display
            const formatDuration = (seconds) => {
                const hrs = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;
                if (hrs > 0) {
                    return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            // Start recording
            const startRecording = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const mediaRecorder = new MediaRecorder(stream);
                    const chunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                        }
                    };

                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        setAudioBlob(blob);
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    setRecorder(mediaRecorder);
                    setIsRecording(true);
                    setIsPaused(false);
                    startTimeRef.current = Date.now();
                    pausedTimeRef.current = 0;

                    // Start duration timer
                    intervalRef.current = setInterval(() => {
                        setDuration(Math.floor((Date.now() - startTimeRef.current - pausedTimeRef.current) / 1000));
                    }, 1000);

                } catch (error) {
                    alert('Failed to access microphone. Please check permissions.');
                    console.error('Recording error:', error);
                }
            };

            // Pause/Resume recording
            const togglePause = () => {
                if (!recorder) return;

                if (isPaused) {
                    // Resume
                    recorder.resume();
                    setIsPaused(false);
                    startTimeRef.current = Date.now() - (duration * 1000);
                    
                    intervalRef.current = setInterval(() => {
                        setDuration(Math.floor((Date.now() - startTimeRef.current - pausedTimeRef.current) / 1000));
                    }, 1000);
                } else {
                    // Pause
                    recorder.pause();
                    setIsPaused(true);
                    clearInterval(intervalRef.current);
                }
            };

            // Stop recording
            const stopRecording = () => {
                if (recorder && recorder.state !== 'inactive') {
                    recorder.stop();
                }
                setIsRecording(false);
                setIsPaused(false);
                setRecorder(null);
                clearInterval(intervalRef.current);
            };

            // Download audio file
            const downloadAudio = () => {
                if (!audioBlob) return;

                const url = URL.createObjectURL(audioBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `deposition-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // Reset for new recording
            const reset = () => {
                setDuration(0);
                setAudioBlob(null);
                pausedTimeRef.current = 0;
            };

            // Get status info
            const getStatus = () => {
                if (!isRecording && !audioBlob) return { text: 'Ready', class: 'status-stopped' };
                if (isRecording && isPaused) return { text: 'Paused', class: 'status-paused' };
                if (isRecording) return { text: 'Recording', class: 'status-recording' };
                return { text: 'Completed', class: 'status-stopped' };
            };

            const status = getStatus();

            return (
                <div className="deposition-mode">
                    <h2>🎙️ Deposition Mode</h2>
                    <p>Streamlined recording for depositions and interviews</p>
                    
                    <div className="deposition-controls">
                        {!isRecording && !audioBlob && (
                            <button 
                                className="btn-deposition btn-deposition-start"
                                onClick={startRecording}
                            >
                                ▶️ Start Recording
                            </button>
                        )}
                        
                        {isRecording && (
                            <>
                                <button 
                                    className={`btn-deposition ${isPaused ? 'btn-deposition-resume' : 'btn-deposition-pause'}`}
                                    onClick={togglePause}
                                >
                                    {isPaused ? '▶️ Resume' : '⏸️ Pause'}
                                </button>
                                
                                <button 
                                    className="btn-deposition btn-deposition-stop"
                                    onClick={stopRecording}
                                >
                                    ⏹️ Stop
                                </button>
                            </>
                        )}
                        
                        {audioBlob && !isRecording && (
                            <>
                                <button 
                                    className="btn-deposition btn-deposition-start"
                                    onClick={() => { reset(); startRecording(); }}
                                >
                                    🔄 New Recording
                                </button>
                                
                                <button 
                                    className="btn-deposition btn-deposition-pause"
                                    onClick={downloadAudio}
                                >
                                    💾 Download Audio
                                </button>
                            </>
                        )}
                    </div>

                    <div className="deposition-status">
                        <div className={`status-indicator ${status.class}`}></div>
                        <span>{status.text}</span>
                    </div>

                    <div className="deposition-info">
                        <div className="info-item">
                            <span className="info-value">{formatDuration(duration)}</span>
                            <span className="info-label">Duration</span>
                        </div>
                        <div className="info-item">
                            <span className="info-value">{audioBlob ? 'Yes' : 'No'}</span>
                            <span className="info-label">Audio Saved</span>
                        </div>
                        <div className="info-item">
                            <span className="info-value">{isRecording ? 'Active' : 'Inactive'}</span>
                            <span className="info-label">Session</span>
                        </div>
                    </div>
                </div>
            );
        }
        
        // Main App Component
        function App() {
            const [hearings, setHearings] = useState([]);
            const [recordings, setRecordings] = useState({});
            const [isDepositionMode, setIsDepositionMode] = useState(false);
            const [showManualInput, setShowManualInput] = useState(false);
            const [manualCase, setManualCase] = useState({
                caseNumber: '',
                clientName: '',
                division: '',
                time: ''
            });
            const fileInputRef = useRef(null);
            
            // Parse CSV file
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const rows = text.split('\n').filter(row => row.trim());
                    const headers = rows[0].split(',').map(h => h.trim());
                    
                    const data = rows.slice(1).map(row => {
                        const values = row.split(',').map(v => v.trim());
                        const hearing = {};
                        headers.forEach((header, index) => {
                            hearing[header] = values[index] || '';
                        });
                        hearing.id = `${hearing['Case Number']}-${Date.now()}-${Math.random()}`;
                        return hearing;
                    });
                    
                    setHearings(data);
                    
                    // Initialize recordings state
                    const newRecordings = {};
                    data.forEach(hearing => {
                        newRecordings[hearing.id] = {
                            isRecording: false,
                            audioBlob: null,
                            transcript: '',
                            notes: '',
                            duration: 0,
                            status: 'ready'
                        };
                    });
                    setRecordings(newRecordings);
                };
                
                reader.readAsText(file);
            };
            
            // Handle manual case creation
            const handleManualCaseSubmit = (event) => {
                event.preventDefault();
                
                if (!manualCase.caseNumber.trim()) {
                    alert('Case number is required');
                    return;
                }
                
                const newHearing = {
                    'Case Number': manualCase.caseNumber.trim(),
                    'Client Name': manualCase.clientName.trim() || 'Not specified',
                    'Division': manualCase.division.trim() || 'Not specified',
                    'Time': manualCase.time.trim() || new Date().toLocaleTimeString(),
                    id: `${manualCase.caseNumber.trim()}-${Date.now()}-${Math.random()}`
                };
                
                setHearings(prev => [...prev, newHearing]);
                
                // Initialize recording state for new hearing
                setRecordings(prev => ({
                    ...prev,
                    [newHearing.id]: {
                        isRecording: false,
                        audioBlob: null,
                        transcript: '',
                        notes: '',
                        duration: 0,
                        status: 'ready'
                    }
                }));
                
                // Reset form
                setManualCase({
                    caseNumber: '',
                    clientName: '',
                    division: '',
                    time: ''
                });
                setShowManualInput(false);
            };
            
            return (
                <div className="app-container">
                    <div className="header">
                        <h1>Court Hearing Recorder</h1>
                        <p>Record hearings, generate transcripts, and manage case notes - all locally</p>
                    </div>
                    
                    <div className="mode-toggle">
                        <button 
                            className="btn-mode-toggle"
                            onClick={() => setIsDepositionMode(!isDepositionMode)}
                        >
                            {isDepositionMode ? '📋 Switch to Hearing Mode' : '🎙️ Deposition Mode'}
                        </button>
                    </div>

                    {isDepositionMode ? (
                        <DepositionMode />
                    ) : (
                        <>
                            <div className="file-upload">
                                <h2>Add Hearing Cases</h2>
                                <p style={{marginBottom: '20px', color: '#7f8c8d'}}>
                                    Upload a CSV file or add cases manually
                                </p>
                                
                                <div style={{display: 'flex', gap: '15px', justifyContent: 'center', marginBottom: '20px'}}>
                                    <button 
                                        className="btn btn-start"
                                        onClick={() => setShowManualInput(!showManualInput)}
                                        style={{minWidth: '150px'}}
                                    >
                                        ✏️ {showManualInput ? 'Hide Form' : 'Add Manually'}
                                    </button>
                                    
                                    <div className="file-input-wrapper">
                                        <input
                                            ref={fileInputRef}
                                            type="file"
                                            accept=".csv"
                                            onChange={handleFileUpload}
                                            className="file-input"
                                            id="csv-upload"
                                        />
                                        <label htmlFor="csv-upload" className="file-input-label">
                                            📁 Upload CSV
                                        </label>
                                    </div>
                                </div>
                                
                                {showManualInput && (
                                    <form onSubmit={handleManualCaseSubmit} style={{
                                        background: '#f8f9fa',
                                        padding: '20px',
                                        borderRadius: '8px',
                                        border: '1px solid #e9ecef',
                                        marginTop: '20px'
                                    }}>
                                        <h3 style={{marginBottom: '15px', color: '#2c3e50'}}>Add Case Details</h3>
                                        <div style={{
                                            display: 'grid',
                                            gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
                                            gap: '15px',
                                            marginBottom: '20px'
                                        }}>
                                            <div>
                                                <label style={{display: 'block', marginBottom: '5px', fontWeight: '500'}}>
                                                    Case Number *
                                                </label>
                                                <input
                                                    type="text"
                                                    value={manualCase.caseNumber}
                                                    onChange={(e) => setManualCase(prev => ({...prev, caseNumber: e.target.value}))}
                                                    placeholder="e.g., 2024-CR-001"
                                                    required
                                                    style={{
                                                        width: '100%',
                                                        padding: '10px',
                                                        border: '1px solid #ddd',
                                                        borderRadius: '6px',
                                                        fontSize: '14px'
                                                    }}
                                                />
                                            </div>
                                            <div>
                                                <label style={{display: 'block', marginBottom: '5px', fontWeight: '500'}}>
                                                    Client Name
                                                </label>
                                                <input
                                                    type="text"
                                                    value={manualCase.clientName}
                                                    onChange={(e) => setManualCase(prev => ({...prev, clientName: e.target.value}))}
                                                    placeholder="e.g., John Doe"
                                                    style={{
                                                        width: '100%',
                                                        padding: '10px',
                                                        border: '1px solid #ddd',
                                                        borderRadius: '6px',
                                                        fontSize: '14px'
                                                    }}
                                                />
                                            </div>
                                            <div>
                                                <label style={{display: 'block', marginBottom: '5px', fontWeight: '500'}}>
                                                    Division
                                                </label>
                                                <input
                                                    type="text"
                                                    value={manualCase.division}
                                                    onChange={(e) => setManualCase(prev => ({...prev, division: e.target.value}))}
                                                    placeholder="e.g., Criminal, Civil"
                                                    style={{
                                                        width: '100%',
                                                        padding: '10px',
                                                        border: '1px solid #ddd',
                                                        borderRadius: '6px',
                                                        fontSize: '14px'
                                                    }}
                                                />
                                            </div>
                                            <div>
                                                <label style={{display: 'block', marginBottom: '5px', fontWeight: '500'}}>
                                                    Scheduled Time
                                                </label>
                                                <input
                                                    type="text"
                                                    value={manualCase.time}
                                                    onChange={(e) => setManualCase(prev => ({...prev, time: e.target.value}))}
                                                    placeholder="e.g., 9:00 AM"
                                                    style={{
                                                        width: '100%',
                                                        padding: '10px',
                                                        border: '1px solid #ddd',
                                                        borderRadius: '6px',
                                                        fontSize: '14px'
                                                    }}
                                                />
                                            </div>
                                        </div>
                                        <div style={{display: 'flex', gap: '10px', justifyContent: 'center'}}>
                                            <button 
                                                type="submit" 
                                                className="btn btn-start"
                                                style={{minWidth: '120px'}}
                                            >
                                                ✅ Add Case
                                            </button>
                                            <button 
                                                type="button" 
                                                className="btn btn-stop"
                                                onClick={() => setShowManualInput(false)}
                                                style={{minWidth: '120px'}}
                                            >
                                                ❌ Cancel
                                            </button>
                                        </div>
                                    </form>
                                )}
                            </div>
                    
                    {hearings.length > 0 ? (
                        <div className="hearings-grid">
                            {hearings.map(hearing => (
                                <HearingTile
                                    key={hearing.id}
                                    hearing={hearing}
                                    recording={recordings[hearing.id]}
                                    onUpdateRecording={(update) => {
                                        setRecordings(prev => ({
                                            ...prev,
                                            [hearing.id]: { ...prev[hearing.id], ...update }
                                        }));
                                    }}
                                />
                            ))}
                        </div>
                    ) : (
                        <div className="empty-state">
                            <h3>No hearings loaded</h3>
                            <p>Upload a CSV file or add cases manually to get started</p>
                        </div>
                    )}
                        </>
                    )}
                </div>
            );
        }
        
        // Speaking Time Tracker utilities
        const speakingTimeUtils = {
            initializeSpeakingTime: function(parties = ['State', 'Defense', 'Court']) {
                return {
                    parties: parties.reduce((acc, party) => {
                        acc[party] = { totalTime: 0, segments: [] };
                        return acc;
                    }, {}),
                    currentSpeaker: null,
                    startTime: null,
                    hearingStartTime: null,
                    hearingEndTime: null,
                    isActive: false,
                    isPaused: false,
                    timeline: []
                };
            },
            
            startSpeaking: function(state, party) {
                const now = Date.now();
                const newState = { ...state };
                
                if (!newState.hearingStartTime) {
                    newState.hearingStartTime = now;
                    newState.isActive = true;
                }
                
                if (newState.currentSpeaker && newState.currentSpeaker !== party) {
                    const duration = now - newState.startTime;
                    newState.parties[newState.currentSpeaker].totalTime += duration;
                    newState.parties[newState.currentSpeaker].segments.push({
                        start: newState.startTime, end: now, duration
                    });
                    newState.timeline.push({
                        party: newState.currentSpeaker,
                        start: newState.startTime, end: now, duration
                    });
                }
                
                newState.currentSpeaker = party;
                newState.startTime = now;
                newState.isPaused = false;
                return newState;
            },
            
            stopTracking: function(state) {
                const now = Date.now();
                const newState = { ...state };
                
                if (newState.currentSpeaker && newState.startTime) {
                    const duration = now - newState.startTime;
                    newState.parties[newState.currentSpeaker].totalTime += duration;
                    newState.parties[newState.currentSpeaker].segments.push({
                        start: newState.startTime, end: now, duration
                    });
                    newState.timeline.push({
                        party: newState.currentSpeaker,
                        start: newState.startTime, end: now, duration
                    });
                }
                
                newState.hearingEndTime = now;
                newState.currentSpeaker = null;
                newState.startTime = null;
                newState.isActive = false;
                newState.isPaused = true;
                return newState;
            },
            
            calculateStatistics: function(state) {
                const totalHearingTime = state.hearingEndTime - state.hearingStartTime;
                const totalSpeakingTime = Object.values(state.parties)
                    .reduce((sum, party) => sum + party.totalTime, 0);
                
                const stats = {
                    totalHearingTime,
                    totalSpeakingTime,
                    silenceTime: totalHearingTime - totalSpeakingTime,
                    parties: {}
                };
                
                Object.entries(state.parties).forEach(([partyName, partyData]) => {
                    stats.parties[partyName] = {
                        totalTime: partyData.totalTime,
                        percentage: totalSpeakingTime > 0 
                            ? (partyData.totalTime / totalSpeakingTime * 100).toFixed(1)
                            : 0,
                        segmentCount: partyData.segments.length,
                        averageSegmentTime: partyData.segments.length > 0
                            ? Math.round(partyData.totalTime / partyData.segments.length)
                            : 0
                    };
                });
                
                return stats;
            },
            
            formatTime: function(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                
                if (hours > 0) {
                    return `${hours}:${(minutes % 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
                } else {
                    return `${minutes}:${(seconds % 60).toString().padStart(2, '0')}`;
                }
            },
            
            generateTextReport: function(state, hearingInfo) {
                const stats = this.calculateStatistics(state);
                let report = `SPEAKING TIME REPORT\n====================\n\n`;
                report += `Case: ${hearingInfo['Case Number']}\n`;
                report += `Client: ${hearingInfo['Client Name']}\n`;
                report += `Division: ${hearingInfo['Division']}\n`;
                report += `Date: ${new Date(state.hearingStartTime).toLocaleString()}\n\n`;
                report += `SUMMARY\n-------\n`;
                report += `Total Hearing Duration: ${this.formatTime(stats.totalHearingTime)}\n`;
                report += `Total Speaking Time: ${this.formatTime(stats.totalSpeakingTime)}\n`;
                report += `Silence/Transitions: ${this.formatTime(stats.silenceTime)}\n\n`;
                report += `SPEAKING TIME BY PARTY\n---------------------\n`;
                
                Object.entries(stats.parties)
                    .sort((a, b) => b[1].totalTime - a[1].totalTime)
                    .forEach(([party, data]) => {
                        report += `${party}:\n`;
                        report += `  Total Time: ${this.formatTime(data.totalTime)} (${data.percentage}%)\n`;
                        report += `  Speaking Turns: ${data.segmentCount}\n`;
                        report += `  Average per Turn: ${this.formatTime(data.averageSegmentTime)}\n\n`;
                    });
                
                return report;
            }
        };

        // Speaking Time Tracker Component
        function SpeakingTimeTracker({ hearing, onSaveReport }) {
            const [speakingState, setSpeakingState] = useState(() => 
                speakingTimeUtils.initializeSpeakingTime(['State', 'Defense', 'Court'])
            );
            const [showReport, setShowReport] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [newPartyName, setNewPartyName] = useState('');
            const intervalRef = useRef(null);
            const chartRef = useRef(null);

            useEffect(() => {
                if (speakingState.isActive && !speakingState.isPaused) {
                    intervalRef.current = setInterval(() => {
                        setCurrentTime(Date.now());
                    }, 100);
                } else {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                    }
                }

                return () => {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                    }
                };
            }, [speakingState.isActive, speakingState.isPaused]);

            useEffect(() => {
                if (showReport && speakingState.hearingEndTime) {
                    const canvas = document.getElementById(`chart-${hearing.id}`);
                    if (canvas && Chart) {
                        if (chartRef.current) {
                            chartRef.current.destroy();
                        }
                        
                        const stats = speakingTimeUtils.calculateStatistics(speakingState);
                        const chartData = {
                            labels: Object.keys(stats.parties),
                            datasets: [{
                                data: Object.values(stats.parties).map(p => p.totalTime),
                                backgroundColor: ['#e74c3c', '#3498db', '#95a5a6', '#f39c12', '#9b59b6'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        };
                        
                        chartRef.current = new Chart(canvas, {
                            type: 'pie',
                            data: chartData,
                            options: {
                                responsive: true,
                                plugins: {
                                    legend: {
                                        position: 'bottom',
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                const label = context.label || '';
                                                const value = speakingTimeUtils.formatTime(context.raw);
                                                const percentage = stats.parties[label].percentage;
                                                return `${label}: ${value} (${percentage}%)`;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }, [showReport, speakingState.hearingEndTime]);

            const handlePartyClick = (party) => {
                if (!speakingState.isActive || speakingState.isPaused) {
                    setSpeakingState(state => speakingTimeUtils.startSpeaking(state, party));
                } else if (speakingState.currentSpeaker !== party) {
                    setSpeakingState(state => speakingTimeUtils.startSpeaking(state, party));
                }
            };

            const handleRecess = () => {
                setSpeakingState(state => speakingTimeUtils.stopTracking(state));
                setShowReport(true);
            };

            const handleReset = () => {
                setSpeakingState(speakingTimeUtils.initializeSpeakingTime(Object.keys(speakingState.parties)));
                setShowReport(false);
                setCurrentTime(0);
                if (chartRef.current) {
                    chartRef.current.destroy();
                    chartRef.current = null;
                }
            };

            const handleAddParty = () => {
                if (newPartyName.trim()) {
                    setSpeakingState(state => {
                        const newState = { ...state };
                        if (!newState.parties[newPartyName.trim()]) {
                            newState.parties[newPartyName.trim()] = { totalTime: 0, segments: [] };
                        }
                        return newState;
                    });
                    setNewPartyName('');
                }
            };

            const getCurrentSpeakerTime = () => {
                if (speakingState.currentSpeaker && speakingState.startTime) {
                    const elapsed = (currentTime || Date.now()) - speakingState.startTime;
                    return speakingTimeUtils.formatTime(elapsed);
                }
                return '0:00';
            };

            const getTotalHearingTime = () => {
                if (speakingState.hearingStartTime) {
                    const endTime = speakingState.hearingEndTime || currentTime || Date.now();
                    return speakingTimeUtils.formatTime(endTime - speakingState.hearingStartTime);
                }
                return '0:00';
            };

            const stats = showReport ? speakingTimeUtils.calculateStatistics(speakingState) : null;

            return React.createElement('div', { className: 'speaking-time-tracker' },
                React.createElement('div', { className: 'tracker-header' },
                    React.createElement('h3', null, '⏱️ Speaking Time Tracker'),
                    React.createElement('div', { className: 'hearing-timer' },
                        'Total Time: ',
                        React.createElement('span', { className: 'timer-display' }, getTotalHearingTime())
                    )
                ),
                !showReport ? (
                    React.createElement(React.Fragment, null,
                        React.createElement('div', { className: 'party-buttons' },
                            Object.keys(speakingState.parties).map(party =>
                                React.createElement('button', {
                                    key: party,
                                    className: `party-button ${speakingState.currentSpeaker === party ? 'active' : ''}`,
                                    onClick: () => handlePartyClick(party)
                                },
                                    React.createElement('div', { className: 'party-name' }, party),
                                    React.createElement('div', { className: 'party-time' },
                                        speakingState.currentSpeaker === party 
                                            ? getCurrentSpeakerTime()
                                            : speakingTimeUtils.formatTime(speakingState.parties[party].totalTime)
                                    )
                                )
                            )
                        ),
                        React.createElement('div', { className: 'tracker-controls' },
                            React.createElement('button', {
                                className: 'btn btn-recess',
                                onClick: handleRecess,
                                disabled: !speakingState.isActive
                            }, '⏸️ Recess'),
                            React.createElement('button', {
                                className: 'btn btn-reset',
                                onClick: handleReset
                            }, '🔄 Reset')
                        ),
                        React.createElement('div', { className: 'add-party-section' },
                            React.createElement('input', {
                                type: 'text',
                                placeholder: 'Add party...',
                                value: newPartyName,
                                onChange: (e) => setNewPartyName(e.target.value),
                                onKeyPress: (e) => e.key === 'Enter' && handleAddParty(),
                                className: 'add-party-input'
                            }),
                            React.createElement('button', {
                                className: 'btn btn-add',
                                onClick: handleAddParty
                            }, '➕ Add')
                        ),
                        speakingState.currentSpeaker && React.createElement('div', { className: 'current-speaker-indicator' },
                            React.createElement('div', { className: 'speaker-label' }, 'Now Speaking:'),
                            React.createElement('div', { className: 'speaker-name' }, speakingState.currentSpeaker),
                            React.createElement('div', { className: 'speaker-time' }, getCurrentSpeakerTime())
                        )
                    )
                ) : (
                    React.createElement('div', { className: 'speaking-report' },
                        React.createElement('h4', null, '📊 Speaking Time Report'),
                        React.createElement('div', { className: 'report-summary' },
                            React.createElement('div', { className: 'summary-item' },
                                React.createElement('span', { className: 'label' }, 'Total Duration:'),
                                React.createElement('span', { className: 'value' }, speakingTimeUtils.formatTime(stats.totalHearingTime))
                            ),
                            React.createElement('div', { className: 'summary-item' },
                                React.createElement('span', { className: 'label' }, 'Speaking Time:'),
                                React.createElement('span', { className: 'value' }, speakingTimeUtils.formatTime(stats.totalSpeakingTime))
                            ),
                            React.createElement('div', { className: 'summary-item' },
                                React.createElement('span', { className: 'label' }, 'Silence/Transitions:'),
                                React.createElement('span', { className: 'value' }, speakingTimeUtils.formatTime(stats.silenceTime))
                            )
                        ),
                        React.createElement('div', { className: 'party-stats' },
                            Object.entries(stats.parties)
                                .sort((a, b) => b[1].totalTime - a[1].totalTime)
                                .map(([party, data]) =>
                                    React.createElement('div', { key: party, className: 'party-stat-item' },
                                        React.createElement('div', { className: 'party-stat-header' },
                                            React.createElement('span', { className: 'party-name' }, party),
                                            React.createElement('span', { className: 'party-percentage' }, data.percentage + '%')
                                        ),
                                        React.createElement('div', { className: 'party-stat-details' },
                                            React.createElement('span', null, 'Time: ' + speakingTimeUtils.formatTime(data.totalTime)),
                                            React.createElement('span', null, 'Turns: ' + data.segmentCount),
                                            React.createElement('span', null, 'Avg: ' + speakingTimeUtils.formatTime(data.averageSegmentTime))
                                        ),
                                        React.createElement('div', { className: 'party-stat-bar' },
                                            React.createElement('div', { 
                                                className: 'party-stat-fill',
                                                style: { width: data.percentage + '%' }
                                            })
                                        )
                                    )
                                )
                        ),
                        React.createElement('div', { className: 'chart-container' },
                            React.createElement('canvas', { id: `chart-${hearing.id}`, width: 300, height: 300 })
                        ),
                        React.createElement('div', { className: 'report-actions' },
                            React.createElement('button', {
                                className: 'btn btn-save',
                                onClick: () => {
                                    if (onSaveReport) {
                                        onSaveReport({
                                            report: speakingTimeUtils.generateTextReport(speakingState, hearing),
                                            stats,
                                            timestamp: Date.now()
                                        });
                                    }
                                }
                            }, '💾 Save Report'),
                            React.createElement('button', {
                                className: 'btn btn-download',
                                onClick: () => {
                                    const report = speakingTimeUtils.generateTextReport(speakingState, hearing);
                                    const blob = new Blob([report], { type: 'text/plain' });
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = `${hearing['Case Number']}_speaking_time_report.txt`;
                                    a.click();
                                    URL.revokeObjectURL(url);
                                }
                            }, '📥 Download Report'),
                            React.createElement('button', {
                                className: 'btn btn-close',
                                onClick: () => setShowReport(false)
                            }, '✖️ Close')
                        )
                    )
                )
            );
        }

        // Hearing Tile Component
        function HearingTile({ hearing, recording, onUpdateRecording }) {
            const [recorder, setRecorder] = useState(null);
            const [startTime, setStartTime] = useState(null);
            const intervalRef = useRef(null);
            const [showSpeakingTracker, setShowSpeakingTracker] = useState(false);
            
            useEffect(() => {
                return () => {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                    }
                };
            }, []);
            
            const startRecording = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const mediaRecorder = new MediaRecorder(stream);
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        chunks.push(e.data);
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        onUpdateRecording({ 
                            audioBlob: blob, 
                            isRecording: false,
                            status: 'recorded'
                        });
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    setRecorder(mediaRecorder);
                    setStartTime(Date.now());
                    onUpdateRecording({ isRecording: true, status: 'recording' });
                    
                    // Update duration every second
                    intervalRef.current = setInterval(() => {
                        const duration = Math.floor((Date.now() - Date.now()) / 1000);
                        onUpdateRecording({ duration });
                    }, 1000);
                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('Error accessing microphone. Please check permissions.');
                }
            };
            
            const stopRecording = () => {
                if (recorder && recorder.state !== 'inactive') {
                    recorder.stop();
                    setRecorder(null);
                    clearInterval(intervalRef.current);
                    
                    const duration = Math.floor((Date.now() - startTime) / 1000);
                    onUpdateRecording({ duration });
                }
            };
            
            const generateTranscript = async () => {
                if (!recording.audioBlob) return;
                
                onUpdateRecording({ status: 'processing' });
                
                // In a real implementation, this would call a local transcription service
                // For demo purposes, we'll simulate a transcript
                setTimeout(() => {
                    const mockTranscript = `[Transcript for ${hearing['Case Number']}]\n\n` +
                        `Court proceedings for ${hearing['Client Name']} in ${hearing['Division']} at ${hearing['Time']}.\n\n` +
                        `[This is a mock transcript. In production, this would be generated by a local Whisper/Vosk model.]\n\n` +
                        `Duration: ${formatDuration(recording.duration)}`;
                    
                    onUpdateRecording({ 
                        transcript: mockTranscript,
                        status: 'complete'
                    });
                }, 2000);
            };
            
            const downloadRecording = () => {
                if (!recording.audioBlob) return;
                
                const url = URL.createObjectURL(recording.audioBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${hearing['Case Number']}_recording.webm`;
                a.click();
                URL.revokeObjectURL(url);
            };
            
            const downloadTranscript = () => {
                if (!recording.transcript) return;
                
                const content = `Case: ${hearing['Case Number']}\n` +
                    `Client: ${hearing['Client Name']}\n` +
                    `Division: ${hearing['Division']}\n` +
                    `Time: ${hearing['Time']}\n` +
                    `Duration: ${formatDuration(recording.duration)}\n\n` +
                    `TRANSCRIPT:\n${recording.transcript}\n\n` +
                    `NOTES:\n${recording.notes}`;
                
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${hearing['Case Number']}_transcript.txt`;
                a.click();
                URL.revokeObjectURL(url);
            };
            
            const formatDuration = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };
            
            const getStatusClass = () => {
                switch (recording.status) {
                    case 'recording': return 'recording';
                    case 'processing': return 'processing';
                    case 'complete': return 'complete';
                    default: return '';
                }
            };
            
            return (
                <div className={`hearing-tile ${recording.isRecording ? 'recording' : ''}`}>
                    <div className="case-header">
                        <div className="case-number">{hearing['Case Number']}</div>
                        <div className="client-name">{hearing['Client Name']}</div>
                        <div className="case-info">
                            <span>📍 {hearing['Division']}</span>
                            <span>🕐 {hearing['Time']}</span>
                        </div>
                    </div>
                    
                    <div className="controls">
                        <button
                            className="btn btn-start"
                            onClick={startRecording}
                            disabled={recording.isRecording}
                        >
                            🟢 Start
                        </button>
                        <button
                            className="btn btn-stop"
                            onClick={stopRecording}
                            disabled={!recording.isRecording}
                        >
                            🟥 Stop
                        </button>
                        <button
                            className="btn btn-transcript"
                            onClick={generateTranscript}
                            disabled={!recording.audioBlob || recording.status === 'processing'}
                        >
                            📄 Generate Transcript
                        </button>
                        <button
                            className="btn btn-download"
                            onClick={downloadRecording}
                            disabled={!recording.audioBlob}
                        >
                            💾 Audio
                        </button>
                        <button
                            className="btn btn-download"
                            onClick={downloadTranscript}
                            disabled={!recording.transcript}
                        >
                            📝 Text
                        </button>
                        <button
                            className="btn btn-tracker"
                            onClick={() => setShowSpeakingTracker(!showSpeakingTracker)}
                            style={{ background: '#9b59b6' }}
                        >
                            ⏱️ {showSpeakingTracker ? 'Hide' : 'Show'} Tracker
                        </button>
                    </div>
                    
                    <div className={`status ${getStatusClass()}`}>
                        {recording.isRecording && (
                            <>
                                🔴 Recording
                                <span className="recording-time">
                                    {formatDuration(Math.floor((Date.now() - startTime) / 1000))}
                                </span>
                            </>
                        )}
                        {recording.status === 'processing' && '⏳ Processing transcript...'}
                        {recording.status === 'recorded' && `✓ Recorded (${formatDuration(recording.duration)})`}
                        {recording.status === 'complete' && '✓ Transcript ready'}
                        {recording.status === 'ready' && 'Ready to record'}
                    </div>
                    
                    <div className="notes-section">
                        <label className="notes-label">✏️ Notes</label>
                        <textarea
                            className="notes-textarea"
                            placeholder="Add case notes here..."
                            value={recording.notes}
                            onChange={(e) => onUpdateRecording({ notes: e.target.value })}
                        />
                    </div>
                    
                    {recording.transcript && (
                        <div className="transcript-preview">
                            <strong>Transcript Preview:</strong><br />
                            {recording.transcript}
                        </div>
                    )}
                    
                    {showSpeakingTracker && (
                        <SpeakingTimeTracker 
                            hearing={hearing}
                            onSaveReport={(reportData) => {
                                onUpdateRecording({ 
                                    speakingTimeReport: reportData 
                                });
                                alert('Speaking time report saved!');
                            }}
                        />
                    )}
                </div>
            );
        }
        
        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>